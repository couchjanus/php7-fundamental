# php7-fundamental

# Регулярные выражения

Регулярные выражения — язык поиска подстроки или подстрок в тексте. Для поиска используется паттерн (шаблон, маска), состоящий из символов и метасимволов (символы, которые обозначают не сами себя, а набор символов).

Это довольно мощный инструмент, который может пригодиться во многих случая — поиск, проверка на корректность строки и т.д.

PHP содержит встроенные функции, которые позволяют работать с регулярными выражениями из которых чаще всего используют следующие:

- preg_match (http://php.net/manual/en/function.preg-match.php) — используется для выполнения сопоставления с шаблоном строки. Она возвращает true, если совпадение найдено, и false, если совпадение не найдено;
- preg_match_all(http://php.net/manual/en/function.preg-match-all.php)- Выполняет глобальный поиск шаблона в строке
- preg_split (http://php.net/manual/ru/function.preg-split.php) — используется для разбивки строки по шаблону, результат возвращается в виде числового массива;
- preg_replace (http://php.net/manual/en/function.preg-replace.php) – используется для поиска по шаблону и замены на указанную строку.

Для работы с ними нужен текст, в котором мы будем искать или заменять подстроки, а также само регулярное выражение, описывающее правило поиска.

## синтаксис функций регулярных выражений:

```php
    имя_функции('/шаблон/',объект);
    ?>
```

где:

- «имя_функции» — это либо preg_match, либо preg_split, либо preg_replace
- «/…/» — косые черты обозначают начало и конец регулярного выражения
- «‘/шаблон/'» — шаблон, который нам нужно сопоставить
- «объект» — строка, с которой нужно сопоставлять шаблон.

# Пример использования функций

В PHP регулярное выражение — это строка, которая начинается и заканчивается символом-разделителем. Все, что находится между разделителями и есть регулярное выражение.

Часто используемыми разделителями являются косые черты “/”, знаки решетки “#” и тильды “~”.

## примеры шаблонов с корректными разделителями:

```php
   /foo bar/
   #^[^0-9]$#
   %[a-zA-Z0-9_-]%
```

Если необходимо использовать разделитель внутри шаблона, его нужно экранировать с помощью обратной косой черты. Если разделитель часто используется в шаблоне, в целях удобочитаемости, лучше выбрать другой разделитель для этого шаблона.

```php
   /http:\/\//
   #http://#

```

В PHP разница между preg_match и preg_match_all в том, что функция preg_match найдет только первый match и закончит поиск, в то время как функция preg_match_all вернет все вхождения.

## Пример кода на PHP:

```php
$text = ‘hello world’;
$regexp = ‘/o/’;
$result = preg_match($regexp, $text, $match);
var_dump(
   $result,
   $match
);

int(1)  // вернулось одно вхождение, т.к. функция заканчивает работу

array(1) {
 [0]=>
 string(1) "o" // нам вернулось вхождение, аналогичное запросу, так как метасимволов мы пока не использовали
}

```

## для функции preg_match_all:

```php
$text = ‘hello world’;
$regexp = ‘/o/’;
$result = preg_match_all($regexp, $text, $match);
var_dump(
   $result,
   $match
);

int(2)
array(1) {
 [0]=>
 array(2) {
   [0]=>
   string(1) "o"
   [1]=>
   string(1) "o"
 }
}

```

функция вернула все вхождения, которые есть в нашем тексте.

# Модификаторы шаблонов

Для регулярных выражений существует набор модификаторов, которые меняют работу поиска. Они обозначаются одиночной буквой латинского алфавита и ставятся в конце регулярного выражения, после закрывающего “/”.

- i — символы в шаблоне соответствуют символам как верхнего, так и нижнего регистра.
- m — по умолчанию текст обрабатывается, как однострочная символьная строка.

## Метасимвол начала строки

Метасимвол начала строки '^' соответствует только началу обрабатываемого текста

## Метасимвол конца строки

Метасимвол конца строки '$' соответствует концу текста. 

Если используется модификатор m, метасимволы «начало строки» и «конец строки» также соответствуют позициям перед произвольным символом перевода и строки и, соответственно, после, как и в самом начале, и в самом конце строки.


## Метасимволы в регулярных выражениях

Чаще всего мы заранее не знаем, какой текст нам придется парсить. Заранее известен только примерный набор правил.

### Пример

получить все числа из текста:

```
    Текст: “Привет, твой номер 1528. Запомни его.”

```

Чтобы выбрать любое число, надо собрать все числа, указав “[0123456789]”. 
Более коротко можно задать так: “[0-9]”. 
Для всех цифр существует метасимвол “\d”. Он работает идентично.

Но если мы укажем регулярное выражение “/\d/”, то нам вернётся только первая цифра. Мы можем использовать модификатор “g”, но в таком случае каждая цифра вернется отдельным элементом массива, поскольку будет считаться новым вхождением.

Для того, чтобы вывести подстроку единым вхождением, существуют символы плюс “+” и звездочка “*”. Первый указывает, что нам подойдет подстрока, где есть как минимум один подходящий под набор символ. Второй — что данный набор символов может быть, а может и не быть, и это нормально. 

Помимо этого мы можем указать точное значение подходящих символов так: “{N}”, где N — нужное количество. Или задать “от” и “до”, указав вот так: “{N, M}”.

### Пример:
```
Текст: “Я хочу ходить на работу 2 раза в неделю.”
Надо получить цифру из тексте.

RegExp: “/\d/”


Текст: “Ваш пинкод: 24356” или “У вас нет пинкода.”
Надо получить пинкод или ничего, если его нет.

RegExp: “/\d*/”


Текст: “Номер телефона 89091534357”
Надо получить первые 11 символов, или FALSE, если их меньше.

RegExp: “/\d{11}/”

```
Примерно так же мы работает с буквами, не забывая, что у них бывает регистр. Вот так можно задавать буквы:

```
   [a-z]
   [a-zA-Z]
   [а-яА-Я]

```

C кириллицей указанный диапазон работает по-разному для разных кодировок. В юникоде, например, в этот диапазон не входит буква “ё”. 

## Пример:

```
Текст: “Вот бежит олень” или “Вот ваш индюк”
Надо выбрать либо слово “олень”, либо слово “индюк”.
RegExp: “/[а-яА-Я]+/”
```

Такое выражение выберет все слова, которые есть в предложении и написаны кириллицей. Нам нужно третье слово.

Помимо букв и цифр у нас могут быть еще важные символы:

```
   \s — пробел
   ^ — начало строки
   $ — конец строки
   | — “или”

```

## Пример стал проще:

```
Текст: “Вот бежит олень” или “Вот бежит индюк”
Надо выбрать либо “олень”, либо “индюк”.
RegExp: “/[а-яА-Я]+$/”
```

Если мы точно знаем, что искомое слово последнее, мы ставим “$” и результатом работы будет только тот набор символов, после которого идет конец строки.

## То же самое с началом строки:
```
Текст: “Олень вкусный” или “Индюк вкусный”
Надо выбрать либо “олень”, либо “индюк”.
RegExp:  “/^[а-яА-Я]+/”
```

В некоторых случаях символ “^” обозначает начало строки, но в некоторых — отрицание.

Допустим, мы собрали набор символов, которые нам подходят: “[a-z0-9]” (нас устроит любая маленькая латинская буква или цифра). А теперь предположим, что нас устроит любой символ, кроме этого. Это будет обозначаться вот так: “[^a-z0-9]”.

## Пример:

```
Текст: “Я люблю кушать суп”
Надо выбрать все слова.
RegExp: “[^\s]+”
```

Выбираем все “не пробелы”.

## список основных метасимволов:

```
   \d — соответствует любой цифре; эквивалент [0-9]
   \D — соответствует любому не числовому символу; эквивалент [^0-9]
   \s — соответствует любому символу whitespace; эквивалент [ \t\n\r\f\v]
   \S — соответствует любому не-whitespace символу; эквивалент [^ \t\n\r\f\v]
   \w — соответствует любой букве или цифре; эквивалент [a-zA-Z0-9_]
   \W — наоборот; эквивалент [^a-zA-Z0-9_]
   . — (просто точка) любой символ, кроме перевода “каретки”
```

## Операторы [] и ()

[] используется для группировки нескольких символов вместе. Так мы говорим, что нас устроит любой символ из набора.

### Пример:
```
Текст: “Не могу перевести I dont know, помогите!”
Надо получить весь английский текст.
RegExp: “/[A-Za-z\s]{2,}/”
```

Тут мы собрали в группу (между символами []) все латинские буквы и пробел. При помощи {} указали, что нас интересуют вхождения, где минимум 2 символа, чтобы исключить вхождения из пустых пробелов.

Аналогично мы могли бы получить все русские слова, сделав инверсию: “[^A-Za-z\s]{2,}”.

## Оператор ()

В отличие от [], символы () собирают отмеченные выражения. Их иногда называют “захватом”.

Они нужны для того, чтобы передать выбранный кусок (который, возможно, состоит из нескольких вхождений [] в результат выдачи).

### Пример:

```
Текст: ‘Email you sent was ololo@example.com Is it correct?’
Нам надо выбрать email.
```
Мы выбираем все, что не пробел (потому что первая часть email может содержать любой набор символов), далее должен идти символ @, далее что угодно, кроме точки и пробела, далее точка, далее любой символ латиницы в нижнем регистре…

```
   мы выбираем все, что не пробел: “[^\s]+”
   мы выбираем знак @: “@”
   мы выбираем что угодно, кроме точки и пробела: “[^\s\.]+”
   мы выбираем точку: “\.” (обратный слеш нужен для экранирования метасимвола, так как знак точки описывает любой символ — см. выше)
   мы выбираем любой символ латиницы в нижнем регистре: “[a-z]+”
```

Теперь у нас есть email, собранный по частям. 

## Результат работы preg_match в PHP:

```php
$text = ‘Email you sent was ololo@example.com. Is it correct?’;
$regexp = ‘/[^\s]+@[^\s\.]+\.[a-z]+/’;
$result = preg_match_all($regexp, $text, $match);
var_dump(
   $result,
   $match
);


int(1)
array(1) {
 [0]=>
 array(1) {
   [0]=>
   string(13) "ololo@example.com"
 }
}
```
если теперь нам надо по отдельности получить домен и имя по email Вот тут нам поможет “захват”. Мы просто выбираем, что нам нужно, и оборачиваем знаками (), как в примере:

Было:

```
/[^\s]+@[^\s\.]+\.[a-z]+/

```
Стало:

```
/([^\s]+)@([^\s\.]+\.[a-z]+)/

```
Пробуем:

```php
$text = ‘Email you sent was ololo@example.com. Is it correct?’;
$regexp = ‘/([^\s]+)@([^\s\.]+\.[a-z]+)/’;
$result = preg_match_all($regexp, $text, $match);
var_dump(
   $result,
   $match
);


int(1)
array(3) {
 [0]=>
 array(1) {
   [0]=>
   string(13) "ololo@example.com"
 }
 [1]=>
 array(1) {
   [0]=>
   string(5) "ololo"
 }
 [2]=>
 array(1) {
   [0]=>
   string(7) "example.com"
 }
}
```

В массиве match нулевым элементом всегда идет полное вхождение регулярного выражения. А дальше по очереди идут “захваты”.

В PHP можно именовать “захваты”, используя следующий синтаксис:

```php
/(?<mail>[^\s]+)@(?<domain>[^\s\.]+\.[a-z]+)/

```

Тогда массив матча станет ассоциативным:

```php
$text = ‘Email you sent was ololo@example.com. Is it correct?’;
$regexp = ‘/(?<mail>[^\s]+)@(?<domain>[^\s\.]+\.[a-z]+)/’;
$result = preg_match_all($regexp, $text, $match);
var_dump(
   $result,
   $match
);


int(1)
array(5) {
 [0]=>
 array(1) {
   [0]=>
   string(13) "ololo@example.com"
 }
 ["mail"]=>
 array(1) {
   [0]=>
   string(5) "ololo"
 }
 ["domain"]=>
 array(1) {
   [0]=>
   string(7) "example.com"
 }
}
```

